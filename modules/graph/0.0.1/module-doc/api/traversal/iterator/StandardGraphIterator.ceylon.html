<!DOCTYPE html><html xmlns='http://www.w3.org/1999/xhtml'><head><meta charset='UTF-8'/>
<title>StandardGraphIterator.ceylon</title><link href='../../.resources/favicon.ico' rel='shortcut icon'/>
<link href='../../.resources/ceylon.css' rel='stylesheet' type='text/css'/>
<link href='http://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css'/>
<script type='text/javascript'>var resourceBaseUrl = '../../.resources/'</script><script src='../../.resources/jquery-1.8.2.min.js' type='text/javascript'></script><script src='../../.resources/rainbow.min.js' type='text/javascript'></script><script src='../../.resources/ceylon.js' type='text/javascript'></script><script src='../../.resources/ceylondoc.js' type='text/javascript'></script></head><body><pre data-language='ceylon' style='font-family: Inconsolata, Monaco, Courier, monospace'>import graph {
	AdjacencyGraph
}
import graph.traversal.iterator {
	PropagatorBasedIterator
}
import graph.traversal.propagator {
	GraphPropagator
}
import graph.traversal.visitor {
	TraversalVisitor
}

&quot;Generic traversal by using white/gray/black vertex colors and a collection of vertices waiting to be visited.
 Base for BFS (using a queue) and DFS (using a stack).&quot;
by (&quot;ThorstenSeitz&quot;)
shared abstract class StandardGraphIterator&lt;V,G,Adjacency,P,Visitor&gt;()
		satisfies PropagatorBasedIterator&lt;V,G,P,Adjacency,Visitor&gt;
		given V satisfies Object
		given G satisfies AdjacencyGraph&lt;V&gt;
		given P satisfies GraphPropagator&lt;V,Adjacency&gt;
		given Visitor satisfies TraversalVisitor&lt;V&gt; {

	ColorMap&lt;V&gt; colorMap = ColorMap&lt;V&gt;();

	shared actual V|Finished next() {
		V? source = nextVertex();
		switch (source)
		case (null) {
			return finished;
		}
		case (is V) {
			P propagator = propagatorFor(source);
			propagator.examineVertex();
			for (Adjacency adjacency in propagator.adjacencies) {
				V target = propagator.target(adjacency);
				propagator.examineEdge(adjacency);
				if (shouldFollowVertex(target)) {
					propagator.treeEdge(adjacency);
					discoverVertex(target);
				} else {
					propagator.nonTreeEdge(adjacency);
					if (isBackEdge(target)) {
						propagator.backEdge(adjacency);
					} else {
						propagator.forwardEdge(adjacency);
					}
				}
			}
			colorMap.setColor(source, black);
			propagator.finishVertex();
			return source;
		}
	}

	&quot;Must be called immediately after creation.&quot;
	shared actual void startWith(V vertex) {
		colorMap.clear();
		discoverVertex(vertex);
	}

	shared formal void push(V vertex);

	shared formal V? nextVertex();

	void discoverVertex(V vertex) {
		colorMap.setColor(vertex, gray);
		push(vertex);
	}

	Boolean shouldFollowVertex(V vertex) {
		switch (colorMap.getColor(vertex))
		case (white) { return true; }
		else { return false; }
	}

	Boolean isBackEdge(V vertex) {
		switch (colorMap.getColor(vertex))
		case (gray) { return true; }
		else { return false; }
	}
}
</pre></body></html>